---
layout: post
title: Wothingthing2
tags: [Katex, Mermaid, Markdown]
color: rgb(250, 50, 50)
categories: Demo
feature-img: "assets/thum.png"
thumbnail: "assets/thum6.png"
badges: 
  - label: "OpenGL"
    color: "#00BFFF" 
  - label: "GLFW"
    color: "#20B2AA"
  - label: "ASSIMP"
    color: "#BA55D3"
  - label: "3D/2D"
    color: "#DC143C" 	
  - label: "IMGUI/IMGUIZMO"
    color: "#00599C" 	
  - label: "JSON"
    color: "#ff3e3e"  
---


<div style="display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 20px;">
  <div style="flex: 1; min-width: 250px; border: 1px solid #444; border-radius: 8px; padding: 15px; background-color: #1c1c1c; color: #fff;">
    <h3>프로젝트 소개</h3>
    <p>
      <strong>Wothingthing2</strong>는 솔로 프로젝트로 개발한 <strong>2D 횡스크롤 + 3D 배경 게임</strong>입니다.<br>
      배경은 3D로 구성하고, 플레이어와 몬스터는 2D 스프라이트로 구현하여 <strong>3D/2D 혼합 환경</strong>에서의 게임 경험을 제공합니다.<br>    
      <br>본 프로젝트를 통해 처음으로 <strong>OpenGL 기반 직접 렌더링</strong>을 경험했고,        
      이 과정을 통해 <strong>렌더링 파이프라인, 자료 구조 설계, 패턴 적용</strong> 등 엔진 없이 게임을 개발하는 경험과 전문성을 쌓을 수 있었습니다.
    </p>
  </div>

  <div style="flex: 1; min-width: 250px; border: 1px solid #444; border-radius: 8px; padding: 15px; background-color: #1c1c1c; color: #fff;">
    <h3>프로젝트 정보</h3>
    <ul>
      <li><strong>역할 :</strong> Programmer</li>
      <li><strong>팀 규모 :</strong> 1명 (프로그래머 1명)</li>
      <li><strong>개발 기간 :</strong> 7개월 </li>
      <li><strong>엔진 :</strong> 자체 엔진</li>
	  <li><strong>사용 기술 & 스택 :</strong><br>
  - ASSIMP (3D 모델 로딩)<br>
  - IMGUI / IMGUIZMO (개발용 GUI)<br>
  - JSON Serializer (데이터 직렬화)<br>
  - Visual Leak Detector(메모리 누수 탐지기)<br>
  - OpenGL (렌더링)
</li>
    </ul>
  </div>
</div>

---


# 최종결과물
<iframe width="960" height="515" src="https://www.youtube.com/embed/aEGslSrzbmI" 
        title="Wothingthing2" frameborder="0" 
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
        allowfullscreen></iframe>
---
  
<div style="
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
  margin: 30px 0;
  flex-wrap: wrap;
">
  <img src="/assets/normal.gif" alt="normal"
       style="flex: 1; min-width: 55%; height: 420px; object-fit: cover; border-radius: 8px;" />

  <img src="/assets/cone.gif" alt="cone"
       style="flex: 1; min-width: 55%; height: 420px; object-fit: cover; border-radius: 8px;" />
</div>

## 주요 구현 내용

### 1. Behavior Tree 구현
- Composite, Decorator, Action, Condition 노드 구조를 갖춘 범용 **Behavior Tree** 프레임워크를 **직접 설계 및 구현**했습니다.
- Running 상태 지속 및 **중단(Abort)** 을 지원해 AI가 특정 패턴 수행 중 플레이어 행동(회피, 점프 등)에 따라
즉시 다른 행동으로 전환할 수 있는 **인터럽트(Interrupt)** 가능한 비동기적 AI 구조를 완성했습니다.

### 2. Blackboard & Message System (AI 데이터 및 이벤트 공유)
- 모든 노드가 접근 가능한 **공유 메모리(BlackBoard)** 를 구현하여 AI와 플레이어의 위치, 체력, 상태 등 전역 데이터를 일관성 있게 관리했습니다.
- BlackBoard 내부에 참조 캐싱을 적용해 매 프레임마다 불필요한 포인터 탐색을 최소화하여 실시간 성능 최적화를 달성했습니다.
- **SendMsg(name, isInterrupt)** 기반의 비동기 메시지 큐 시스템을 통해 외부 이벤트(예: 피격, 상태 이상)를
Behavior Tree에 전달 → 현재 Running 노드를 Abort → 새로운 노드로 전환하는 구조를 설계했습니다.

### 3. Raycast & 충돌 판정 시스템 구현
- 광선의 매개변수 방정식 **P(t)=O + tD**와 **슬랩(Slab) 교차 방식**에 기반해 각 축별 t-interval(txmin~txmax, tymin~tymax)의 교집합을 계산하여 Ray–AABB 충돌 여부와 tEnter/tExit를 수학적으로 산출하는 레이캐스팅 알고리즘을 직접 구현했습니다.
- 정규화, 평행 레이(EPS), 무한대 구간(INF) 등 특수 케이스를 처리해 안정적인 최근접 **충돌 판정(closest-hit)** 시스템을 완성했습니다.

<!--### 4. FSM & Animation (상태 제어)
- 플레이어 및 몬스터 행동을 제어하기 위해 **Finite State Machine(FSM)** 구조로 AI와 애니메이션 시스템을 설계했습니다.  
- 공격, 이동, 피격 등 상황별 행동을 모듈화하여 **확장성과 유지보수성**을 확보하고, 자연스러운 게임플레이를 구현했습니다.  
- 이를 통해 **게임 캐릭터의 동작 논리 설계와 애니메이션 전환**에 대한 경험을 얻었습니다.-->

### 4. 빌보드 렌더링
- 2D 스프라이트 캐릭터가 3D 배경 속에서 항상 카메라 방향을 바라보도록 **빌보드 렌더링**을 적용했습니다.  
- 카메라 이동 시 캐릭터가 가려지거나 왜곡되지 않도록 조정하여 **플레이어 시야와 게임 몰입감**을 향상시켰습니다.

### 5. Skybox 구현  
- 게임 배경의 몰입감을 높이기 위해 **Skybox**를 구현하여 3D 환경에 자연스러운 하늘과 원근감을 추가했습니다.  
- Skybox의 렌더링 순서를 고려하고, 카메라 이동에 따른 동적 적용을 통해 **씬 구성과 환경 디자인 이해**를 강화했습니다.

### 6. ASSIMP 모델 로딩 / JSON Serializer 
- **ASSIMP**를 이용해 외부 3D 모델을 로드하고, Mesh와 Material 데이터를 게임 내 렌더링에 맞게 처리하여 모델이 올바르게 화면에 표시되도록 구현했습니다.  
- 게임 상태 및 레벨 정보를 **JSON Serializer**로 저장/불러오기 가능하도록 구현하여 **데이터 관리와 재사용성**을 확보했습니다.  
- 이를 통해 **리소스 관리와 직렬화 구조 설계 능력**을 체득할 수 있었습니다.


---

<div style="text-align: center; margin: 30px 0;">
  <img src="/assets/player_particle.gif" alt="player_particle" 
       style="width: 80%; max-width: 1200px; height: auto; border-radius: 8px;" />
  <p style="color: #aaa; font-size: 0.9em;">▲ 파티클을 이용한 스킬 모습</p>
</div>

# 어려웠던 점과 해결 방안
### 1. 투명/불투명 오브젝트 렌더링 문제

#### 문제
- 초기에는 **투명 오브젝트가 불투명 오브젝트를 가리는 현상**이 발생했습니다.

#### 원인
- **알파 블렌딩(Alpha Blending) 적용 시 렌더링 순서가 중요**
- **Depth Buffer 동작 방식 때문에 발생**  
  - GPU는 기본적으로 **각 픽셀에 가장 가까운 오브젝트만 그리는 방식(depth test)**을 사용  
  - 불투명 오브젝트는 depth test를 통과한 후 그려지고, 뒤에 있는 픽셀은 덮어쓰지 않음  
  - 하지만 투명 오브젝트는 **픽셀 색상을 기존 색상과 섞어야 하기 때문에 뒤에 있는 오브젝트도 고려**해야 함  
  - 따라서 투명 오브젝트를 먼저 그리면 뒤에 있는 불투명 오브젝트가 이미 depth buffer에 막혀 보이지 않게 됨 

#### 문제 코드
````cpp
// 투명 불투명 오브젝트들을 구분하지도 않으며 한꺼번에 모든 오브젝트를 투명여부에 상관없이 그리고 있는 상황 
for (auto obj : objs)
{		
    //비활성화 오브젝트는 Draw(X)
    if (!obj->GetActive())
	    continue;
	   
    auto model = obj->GetModel();

    if (model && obj->GetIs3D())
    {
        m_vShdr[int(SHADER_REF::THREE_DIMENSIONS)]->Use();
		
        //Model View Location Uniform 핸들		
        GLint MVP_Location = glGetUniformLocation(shdr_handle_3D, "uMVP");
        assert(MVP_Location >= 0);
        
        //각 오브젝트 Transform 
        Transform* trs = dynamic_cast<Transform*>(obj->FindComponent<Transform>());
        assert(trs != nullptr);		
		.
		.
		.
    
	}
````

#### 해결
  - 검색을 통하여 **투명 오브젝트와 불투명 오브젝트를 분리하여 렌더링**  
  - 불투명 오브젝트: depth test 적용 후 먼저 렌더링  
  - 투명 오브젝트: 카메라로부터 먼 순서대로 뒤에서 앞으로 정렬 후 렌더링  

#### 개선된 코드
````cpp
//그리기 전 투명과 불투명 오브젝트들을 구분하는 작업 먼저 수행
void RenderManager::BeforeDraw()
{
    //매프레임 채워져있던 메모리들을 정리 후 수행
    m_vTransParnetObject.clear();
    m_vOpaqueObject.clear();
	
    auto objs = GameObjectManager::GetInstance()->GetAllObjects();
    
    for (const auto& obj : objs)
    {		
        for (int i = 0;i < obj->GetModel()->GetMeshes().size();i++)
        {
            Material* mat = obj->GetModel()->GetMeshes()[i]->GetMaterial();
            if (mat)
			{			
                //알파값 존재 여부			
                if (mat->GetHasAlphaChannel())
                {
                    //투명
                    m_vTransParnetObject.push_back(obj);
                }						
                else
                {
                    //불투명
                    m_vOpaqueObject.push_back(obj);
                }
            }
        }
        .
        .
        .
    }

void RenderManager::Draw()
{
    //그리기 전
    BeforeDraw();
    
	//그리기
    //불투명 먼저
    for (const auto obj : m_vOpaqueObject)
    {	
        //비활성화 오브젝트는 Draw(X)
        if (!obj->GetActive())
	        continue;
	    .
	    .
	    .
    }
	
    //그리고 투명
    for(const auto obj : m_vTransParnetObject)
    {
        .
        .
        .
    }
	
    //그린 후
    EndDraw();
}

//다 그린 후 메모리 Capacity까지 온전히 정리(삭제)	
void RenderManager::EndDraw()
{		
    std::vector<GameObject*> TransParent_temp,Opaque_temp;
    TransParent_temp.swap(m_vTransParnetObject);
    Opaque_temp.swap(m_vOpaqueObject);
}
````
<br>

#### <span style="font-size:32px; font-weight:900;">성과 및 결과</span>
- <span style="font-weight:bold; color:rgb(255,200,100);">렌더링 오류 발생 빈도 0%</span> 달성  
- <span style="font-weight:bold;">렌더링 구조 전반에 대한 실전 기반 이해 확보</span>
- 투명 오브젝트가 불투명 오브젝트를 가리는 문제가 해결됨  
- **자연스러운 반투명 효과와 씬 렌더링 안정성** 확보  
- OpenGL 렌더링 파이프라인, 셰이더, Mesh/Material 구조 이해 심화<br>

<div style="margin-top:60px;"></div>
---
<div style="margin-top:60px;"></div>

### 2.몬스터 AI 구현과 상태 관리 문제
- **패턴이 다소 간단한 몬스터들은 Behavior Tree를 사용하지 않고 FSM구조를 통해 구현하였습니다.**
#### 문제
- 몬스터 AI를 구현하면서 **상태 클래스와 행동 로직이 섞이는 문제**가 발생했습니다.  
- 상태 클래스(`IdleState`, `RangedState`, `TraceState`) 안에서 **몬스터별 공격 분기문(if/else)**이 많아져 코드가 복잡하고 유지보수가 어려웠습니다.  
- 새로운 몬스터 추가 시 상태 클래스를 수정해야 하는 **확장성 부족** 문제도 존재했습니다.

#### 원인
- 상태 전환과 몬스터별 행동을 한 클래스에서 모두 처리 → 단일 책임 원칙(SRP) 위반  
- 분기문 증가 → 코드 가독성 저하, 유지보수 어려움  
- 새로운 몬스터 추가 시 상태 클래스 수정 필요 → 확장성 부족  

#### 문제 코드 예시 (기존 구조)
```cpp
//원거리 공격 State
class RangedState : public BaseState 
{
public:
    void Update() override 
    {	
        Monster* mon_comp = dynamic_cast<Monster*>(GetAI()->GetOwner()->FindComponent<Monster>());
        //몬스터 일때
        if (mon_comp != nullptr) 
        {
            // 몬스터 타입별 공격 분기
            auto type = mon_comp->GetType();
            //아랍 병사 : 칼 던지기 공격
            if (type == MonsterType::ArabSoldier)
                Bullet* bullet = mon_comp->GetBulletFactory()->CreateBullet(BULLET_TYPE::KNIFE);
            //일반 병사 : 총알 발사 공격
            else if (type == MonsterType::GenericSoldier) 
                Bullet* bullet = mon_comp->GetBulletFactory()->CreateBullet(BULLET_TYPE::NORMAL);
            //계속 늘어나는 else if 문
            else if (type == MonsterType::other)
            {
            }
            .
            .
            .
        }
    }
};
```


### 해결책: 전략 패턴 적용

- 몬스터별 행동을 별도 전략 객체로 분리 (Strategy Pattern)
- 행동 인터페이스(`IRangedAttackBehavior`, `IIdleBehavior`) 정의
- 상태 클래스는 행동 호출만 수행, 실제 행동은 전략 객체에 위임
- AI 클래스는 상태 전환만 담당


### 개선된 코드 구조
````cpp
// 행동 인터페이스
class IRangedAttackBehavior 
{
public:
    virtual void Execute(Monster* _mon) = 0;
    virtual ~IRangedAttackBehavior() = default;
};

// GenericSoldier 전용 행동
class GenericSoldierRanged : public IRangedAttackBehavior 
{
public:
    void Execute(Monster* _mon) override 
    {
        Bullet* bullet = _mon->GetBulletFactory()->CreateBullet(BULLET_TYPE::NORMAL);
        EventManager::GetInstance()->SetActiveTrue(bullet->GetOwner());    
    }
};

// ArabSoldier 전용 행동
class ArabSoldierRanged : public IRangedAttackBehavior 
{
public:
    void Execute(Monster* _mon) override 
    {
        Bullet* bullet = _mon->GetBulletFactory()->CreateBullet(BULLET_TYPE::KNIFE);
        EventManager::GetInstance()->SetActiveTrue(bullet->GetOwner());
    }
};
````


#### 몬스터 전략 클래스
<div class="mermaid">
flowchart TD
    MonsterAI[MonsterAI]
    RangedState2[RangedState]
    MonsterAI -->|SetState| RangedState2
    RangedState2 -->|Update| IRangedBehavior[IRangedAttackBehavior]
    IRangedBehavior --> GenericSoldierBehavior[GenericSoldierRanged]
    IRangedBehavior --> ArabSoldierBehavior[ArabSoldierRanged]
</div>

#### <span style="font-size:32px; font-weight:900;">성과 및 결과</span>
- <span style="font-weight:bold; color:rgb(255,200,100);">AI 관련 코드 수정량 약 40% 감소</span>(상태 클래스 내부에서 몬스터별 분기 제거)
- <span style="font-weight:bold;">신규 몬스터 추가 시 수정해야 할 파일 수 4개 → 1개로 감소 </span>(상태 코드는 유지, 전략 클래스만 추가하면 되는 구조로 개선)
- if/else 기반 분기 로직 제거로 <span style="font-weight:bold;">AI Update 로직 가독성 2배 향상</span>
- 상태 전환과 행동 로직이 분리되면서 **FSM 구조의 확장성과 유지보수성 대폭 증가**
- 코드 구조 정리를 통해 **SRP(단일 책임 원칙) 준수 및 디버깅 시간 감소**

<div style="margin-top:60px;"></div>

---

# 배운 점
- OpenGL 3D 기반 **실제 게임 렌더링 파이프라인** 더욱 심도있게 이해할 수 있었습니다. 
- **전략 패턴, 팩토리 패턴 등 디자인 패턴** 적용 및 경험하였습니다.
- 3D 모델 로딩, 충돌 관리, 애니메이션 상태 관리 등 **게임 시스템 핵심 요소 구현** 적용 및 학습하고 실제로 경험할 수 있었습니다.

# 느낀 점
- 프로젝트 규모가 커질수록 코드 복잡도가 증가했지만 **유연성과 유지보수성을 확보하는 방향으로 구조를 지속적으로 개선**하려고 노력했습니다.
- **단일 책임 원칙(SRP)**을 최대한 적용하며 각 모듈의 역할을 명확히 하고, **재사용 가능한 구조**를 만들기 위해 계속 코드 구조를 개선했습니다.  
- SRP와 유연성을 지키면서 **최적의 자료구조와 클래스 구조**를 찾으려 시도하는 과정에서 설계 능력과 문제 해결 능력이 크게 향상되었습니다.  
- 이러한 경험 덕분에, 다음번에 상용 게임 엔진을 사용할 때도 **막연히 기능을 사용하는 것이 아니라, 내부 동작 원리를 이해한 상태에서 기능을 적용**할 수 있다는 자신감을 얻었습니다.  
- 엔진 없이 직접 구현하며 얻은 경험은, 단순히 코드 작성 능력을 넘어서 **게임 시스템 전체를 설계하고 최적화하는 사고**를 기르는 데 큰 도움이 되었습니다.

>  이번 프로젝트를 진행하면서 가장 크게 느낀 점은 **클라이언트 개발에서 작은 설계 결정 하나가 나중에 얼마나 큰 영향을 주는지였습니다.** 
>  초반에 대충 넘긴 부분이 후반에 발목을 잡는 경험을 반복하면서 구조를 처음부터 신중하게 잡는 습관을 가지려 노력중에 있습니다.
>  <br>혼자 개발했지만 그 과정에서 <span style="color:rgb(255,200,100); font-weight:bold;">"왜 실무에서 코드 리뷰가 중요한지", "왜 모듈화가 필수인지", "왜 자료구조가 성능을 좌우하는지" </span>를 실제 상황으로 경험할 수 있었습니다.<br>
>  이런 경험은 책이나 강의로는 절대 얻을 수 없는 몸으로 배우는 인사이트였습니다.
