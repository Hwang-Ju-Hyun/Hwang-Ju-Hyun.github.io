---
layout: post
title: Wothingthing2
tags: [Katex, Mermaid, Markdown]
color: rgb(250, 50, 50)
categories: Demo
feature-img: "assets/thum.png"
thumbnail: "assets/thum.png"
badges: 
  - label: "OpenGL"
    color: "#00BFFF" 
  - label: "GLFW"
    color: "#20B2AA"
  - label: "ASSIMP"
    color: "#BA55D3"
  - label: "3D/2D"
    color: "#DC143C" 	
  - label: "IMGUI/IMGUIZMO"
    color: "#00599C" 	
  - label: "JSON"
    color: "#ff3e3e"  
---


<div style="display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 20px;">
  <div style="flex: 1; min-width: 250px; border: 1px solid #444; border-radius: 8px; padding: 15px; background-color: #1c1c1c; color: #fff;">
    <h3>About</h3>
    <p>
      <strong>Wothingthing2</strong>는 솔로 프로젝트로 개발한 <strong>2D 횡스크롤 + 3D 배경 게임</strong>입니다.<br>
      배경은 3D로 구성하고, 플레이어와 몬스터는 2D 스프라이트로 구현하여 <strong>3D/2D 혼합 환경</strong>에서의 게임 경험을 제공합니다.<br>    
      본 프로젝트를 통해 처음으로 <strong>OpenGL 기반 직접 렌더링</strong>을 경험했고,        
      이 과정을 통해 <strong>렌더링 파이프라인, 자료 구조 설계, 패턴 적용</strong> 등 엔진 없이 게임을 개발하는 경험과 전문성을 쌓을 수 있었습니다.
    </p>
  </div>

  <div style="flex: 1; min-width: 250px; border: 1px solid #444; border-radius: 8px; padding: 15px; background-color: #1c1c1c; color: #fff;">
    <h3>Project Info</h3>
    <ul>
      <li><strong>Role:</strong> Programmer</li>
      <li><strong>Team Size:</strong> 1명 (프로그래머 1명)</li>
      <li><strong>Time Frame:</strong> 4월 ~ 진행중 </li>
      <li><strong>Engine:</strong> Custom Engine</li>
	  <li><strong>Tools & Libraries:</strong><br>
  - ASSIMP (3D 모델 로딩)<br>
  - IMGUI / IMGUIZMO (개발용 GUI)<br>
  - JSON Serializer (데이터 직렬화)<br>
  - Visual Leak Detector(메모리 누수 탐지기)<br>
  - OpenGL (렌더링)
</li>
    </ul>
  </div>
</div>

---

  
<div style="text-align: center; margin: 30px 0;">
  <img src="/assets/normal.gif" alt="normal" 
       style="width: 80%; max-width: 1200px; height: auto; border-radius: 8px;" />
  <p style="color: #aaa; font-size: 0.9em;"></p>
</div>

## 주요 구현 내용

### 1. Object Pooling & Factory Pattern 
- 다수의 몬스터와 오브젝트를 생성/삭제할 때 발생하는 성능 저하 문제를 해결하기 위해 **Object Pooling과 Factory Pattern**을 적용했습니다.  
- 이를 통해 메모리 할당/해제를 최소화하고, 새로운 오브젝트 추가 시 **유지보수성과 확장성**을 확보할 수 있었습니다.  
- 결과적으로 프레임 안정성을 유지하면서, 오브젝트 관리 구조를 효율적으로 설계할 수 있었습니다.

### 2. Real-Time Lighting (실시간 조명)  
- 3D 배경 환경에서 실시간 조명과 그림자를 구현하기 위해 **조명 계산을 직접 셰이더로 구현**했습니다.  
- 각 오브젝트의 Material과 Light 정보를 기반으로 **Phong 모델 기반 조명 계산**을 적용하여 자연스러운 조명 효과를 제공했습니다.  
- 이 과정을 통해 **OpenGL 렌더링 파이프라인과 셰이더 설계**에 대한 이해를 깊이 있게 다질 수 있었습니다.

### 3. AI & Animation (FSM 구조)
- 플레이어 및 몬스터 행동을 제어하기 위해 **Finite State Machine(FSM)** 구조로 AI와 애니메이션 시스템을 설계했습니다.  
- 공격, 이동, 피격 등 상황별 행동을 모듈화하여 **확장성과 유지보수성**을 확보하고, 자연스러운 게임플레이를 구현했습니다.  
- 이를 통해 **게임 캐릭터의 동작 논리 설계와 애니메이션 전환**에 대한 경험을 얻었습니다.

### 4. 빌보드 렌더링
- 2D 스프라이트 캐릭터가 3D 배경 속에서 항상 카메라 방향을 바라보도록 **빌보드 렌더링**을 적용했습니다.  
- 카메라 이동 시 캐릭터가 가려지거나 왜곡되지 않도록 조정하여 **플레이어 시야와 게임 몰입감**을 향상시켰습니다.

### 5. Skybox 구현  
- 게임 배경의 몰입감을 높이기 위해 **Skybox**를 구현하여 3D 환경에 자연스러운 하늘과 원근감을 추가했습니다.  
- Skybox의 렌더링 순서를 고려하고, 카메라 이동에 따른 동적 적용을 통해 **씬 구성과 환경 디자인 이해**를 강화했습니다.

### 6. ASSIMP 모델 로딩 / JSON Serializer 
- **ASSIMP**를 이용해 외부 3D 모델을 로드하고, Mesh와 Material 데이터를 게임 내 렌더링에 맞게 처리하여 모델이 올바르게 화면에 표시되도록 구현했습니다.  
- 게임 상태 및 레벨 정보를 **JSON Serializer**로 저장/불러오기 가능하도록 구현하여 **데이터 관리와 재사용성**을 확보했습니다.  
- 이를 통해 **리소스 관리와 직렬화 구조 설계 능력**을 체득할 수 있었습니다.

### 7. Real-Time Collision Detection(매 프레임 충돌 검사)  
- 게임 내 모든 충돌 가능한 오브젝트를 **Collision Manager**를 통해 매 프레임마다 검사하도록 구현했습니다.  
- 싱글톤 패턴을 활용하여 효율적인 접근과 관리가 가능하며, 충돌 처리 로직을 모듈화하여 **확장성과 유지보수성**을 확보했습니다.  
- 이를 통해 **게임 시스템 핵심인 실시간 충돌 처리** 경험을 얻었습니다.  

---

<div style="text-align: center; margin: 30px 0;">
  <img src="/assets/PARTICLE.gif" alt="PARTICLE" 
       style="width: 80%; max-width: 1200px; height: auto; border-radius: 8px;" />
  <p style="color: #aaa; font-size: 0.9em;">▲ 파티클을 이용한 스킬 모습</p>
</div>

# 어려웠던 점과 해결 방안
### 1. 투명/불투명 오브젝트 렌더링 문제

#### 문제
- 초기에는 **투명 오브젝트가 불투명 오브젝트를 가리는 현상**이 발생했습니다.

#### 원인
- **알파 블렌딩(Alpha Blending) 적용 시 렌더링 순서가 중요**
- **Depth Buffer 동작 방식 때문에 발생**  
  - GPU는 기본적으로 **각 픽셀에 가장 가까운 오브젝트만 그리는 방식(depth test)**을 사용  
  - 불투명 오브젝트는 depth test를 통과한 후 그려지고, 뒤에 있는 픽셀은 덮어쓰지 않음  
  - 하지만 투명 오브젝트는 **픽셀 색상을 기존 색상과 섞어야 하기 때문에 뒤에 있는 오브젝트도 고려**해야 함  
  - 따라서 투명 오브젝트를 먼저 그리면 뒤에 있는 불투명 오브젝트가 이미 depth buffer에 막혀 보이지 않게 됨 

#### 문제 코드
````cpp
// 투명 불투명 오브젝트들을 구분하지도 않으며 한꺼번에 모든 오브젝트를 투명여부에 상관없이 그리고 있는 상황 
for (auto obj : objs)
{		
    //비활성화 오브젝트는 Draw(X)
    if (!obj->GetActive())
	    continue;
	   
    auto model = obj->GetModel();

    if (model && obj->GetIs3D())
    {
        m_vShdr[int(SHADER_REF::THREE_DIMENSIONS)]->Use();
		
        //Model View Location Uniform 핸들		
        GLint MVP_Location = glGetUniformLocation(shdr_handle_3D, "uMVP");
        assert(MVP_Location >= 0);
        
        //각 오브젝트 Transform 
        Transform* trs = dynamic_cast<Transform*>(obj->FindComponent<Transform>());
        assert(trs != nullptr);		
		.
		.
		.
    
	}
````

#### 해결
  - 검색을 통하여 **투명 오브젝트와 불투명 오브젝트를 분리하여 렌더링**  
  - 불투명 오브젝트: depth test 적용 후 먼저 렌더링  
  - 투명 오브젝트: 카메라로부터 먼 순서대로 뒤에서 앞으로 정렬 후 렌더링  

#### 개선된 코드
````cpp
//그리기 전 투명과 불투명 오브젝트들을 구분하는 작업 먼저 수행
void RenderManager::BeforeDraw()
{
    //매프레임 채워져있던 메모리들을 정리 후 수행
    m_vTransParnetObject.clear();
    m_vOpaqueObject.clear();
	
    auto objs = GameObjectManager::GetInstance()->GetAllObjects();
    
    for (const auto& obj : objs)
    {		
        for (int i = 0;i < obj->GetModel()->GetMeshes().size();i++)
        {
            Material* mat = obj->GetModel()->GetMeshes()[i]->GetMaterial();
            if (mat)
			{			
                //알파값 존재 여부			
                if (mat->GetHasAlphaChannel())
                {
                    //투명
                    m_vTransParnetObject.push_back(obj);
                }						
                else
                {
                    //불투명
                    m_vOpaqueObject.push_back(obj);
                }
            }
        }
        .
        .
        .
    }

void RenderManager::Draw()
{
    //그리기 전
    BeforeDraw();
    
	//그리기
    //불투명 먼저
    for (const auto obj : m_vOpaqueObject)
    {	
        //비활성화 오브젝트는 Draw(X)
        if (!obj->GetActive())
	        continue;
	    .
	    .
	    .
    }
	
    //그리고 투명
    for(const auto obj : m_vTransParnetObject)
    {
        .
        .
        .
    }
	
    //그린 후
    EndDraw();
}

//다 그린 후 메모리 Capacity까지 온전히 정리(삭제)	
void RenderManager::EndDraw()
{		
    std::vector<GameObject*> TransParent_temp,Opaque_temp;
    TransParent_temp.swap(m_vTransParnetObject);
    Opaque_temp.swap(m_vOpaqueObject);
}
````

#### 결과

- 투명 오브젝트가 불투명 오브젝트를 가리는 문제가 해결됨  
- **자연스러운 반투명 효과와 씬 렌더링 안정성** 확보  
- OpenGL 렌더링 파이프라인, 셰이더, Mesh/Material 구조 이해 심화

---

### 2.몬스터 AI 구현과 상태 관리 문제

#### 문제
- 몬스터 AI를 구현하면서 **상태 클래스와 행동 로직이 섞이는 문제**가 발생했습니다.  
- 상태 클래스(`IdleState`, `RangedState`, `TraceState`) 안에서 **몬스터별 공격 분기문(if/else)**이 많아져 코드가 복잡하고 유지보수가 어려웠습니다.  
- 새로운 몬스터 추가 시 상태 클래스를 수정해야 하는 **확장성 부족** 문제도 존재했습니다.

#### 원인
- 상태 전환과 몬스터별 행동을 한 클래스에서 모두 처리 → 단일 책임 원칙(SRP) 위반  
- 분기문 증가 → 코드 가독성 저하, 유지보수 어려움  
- 새로운 몬스터 추가 시 상태 클래스 수정 필요 → 확장성 부족  

#### 문제 코드 예시 (기존 구조)
```cpp
//원거리 공격 State
class RangedState : public BaseState 
{
public:
    void Update() override 
    {	
        Monster* mon_comp = dynamic_cast<Monster*>(GetAI()->GetOwner()->FindComponent<Monster>());
        //몬스터 일때
        if (mon_comp != nullptr) 
        {
            // 몬스터 타입별 공격 분기
            auto type = mon_comp->GetType();
            //아랍 병사 : 칼 던지기 공격
            if (type == MonsterType::ArabSoldier)
                Bullet* bullet = mon_comp->GetBulletFactory()->CreateBullet(BULLET_TYPE::KNIFE);
            //일반 병사 : 총알 발사 공격
            else if (type == MonsterType::GenericSoldier) 
                Bullet* bullet = mon_comp->GetBulletFactory()->CreateBullet(BULLET_TYPE::NORMAL);
            //계속 늘어나는 else if 문
            else if (type == MonsterType::other)
            {
            }
            .
            .
            .
        }
    }
};
```


### 해결책: 전략 패턴 적용

- 몬스터별 행동을 별도 전략 객체로 분리 (Strategy Pattern)
- 행동 인터페이스(`IRangedAttackBehavior`, `IIdleBehavior`) 정의
- 상태 클래스는 행동 호출만 수행, 실제 행동은 전략 객체에 위임
- AI 클래스는 상태 전환만 담당


### 개선된 코드 구조
````cpp
// 행동 인터페이스
class IRangedAttackBehavior 
{
public:
    virtual void Execute(Monster* _mon) = 0;
    virtual ~IRangedAttackBehavior() = default;
};

// GenericSoldier 전용 행동
class GenericSoldierRanged : public IRangedAttackBehavior 
{
public:
    void Execute(Monster* _mon) override 
    {
        Bullet* bullet = _mon->GetBulletFactory()->CreateBullet(BULLET_TYPE::NORMAL);
        EventManager::GetInstance()->SetActiveTrue(bullet->GetOwner());    
    }
};

// ArabSoldier 전용 행동
class ArabSoldierRanged : public IRangedAttackBehavior 
{
public:
    void Execute(Monster* _mon) override 
    {
        Bullet* bullet = _mon->GetBulletFactory()->CreateBullet(BULLET_TYPE::KNIFE);
        EventManager::GetInstance()->SetActiveTrue(bullet->GetOwner());
    }
};
````


#### 몬스터 전략 클래스
<div class="mermaid">
flowchart TD
    MonsterAI[MonsterAI]
    RangedState2[RangedState]
    MonsterAI -->|SetState| RangedState2
    RangedState2 -->|Update| IRangedBehavior[IRangedAttackBehavior]
    IRangedBehavior --> GenericSoldierBehavior[GenericSoldierRanged]
    IRangedBehavior --> ArabSoldierBehavior[ArabSoldierRanged]
</div>

---

# 배운 점
- OpenGL 3D 기반 **실제 게임 렌더링 파이프라인** 더욱 심도있게 이해할 수 있었습니다. 
- **전략 패턴, 팩토리 패턴 등 디자인 패턴** 적용 및 경험하였습니다.
- 3D 모델 로딩, 충돌 관리, 애니메이션 상태 관리 등 **게임 시스템 핵심 요소 구현** 적용 및 학습하고 실제로 경험할 수 있었습니다.

# 느낀 점
- 프로젝트가 점점 커지고 코드가 길어지면서, 이전에 힘들었던 기억을 되살리며 **유연성과 유지보수성**을 최대한 확보하려고 노력했습니다.  
- **단일 책임 원칙(SRP)**을 최대한 적용하며 각 모듈의 역할을 명확히 하고, **재사용 가능한 구조**를 만들기 위해 계속 코드 구조를 개선했습니다.  
- SRP와 유연성을 지키면서 **최적의 자료구조와 클래스 구조**를 찾으려 시도하는 과정에서, 설계 능력과 문제 해결 능력이 크게 향상되었습니다.  
- 이러한 경험 덕분에, 다음번에 상용 게임 엔진을 사용할 때도 **막연히 기능을 사용하는 것이 아니라, 내부 동작 원리를 이해한 상태에서 기능을 적용**할 수 있다는 자신감을 얻었습니다.  
- 엔진 없이 직접 구현하며 얻은 경험은, 단순히 코드 작성 능력을 넘어서 **게임 시스템 전체를 설계하고 최적화하는 사고**를 기르는 데 큰 도움이 되었습니다.

>  **하지만 무엇보다도 중요한 것은 협업과 소통의 가치였습니다.**
> 혼자 모든 과정을 경험한 덕분에, 앞으로 협업 환경에서 다른 직군의 어려움을 더 잘 이해할 수 있을 거라 생각합니다.  
> <span style="color:rgb(255,200,100); font-weight:bold;">프로그래머의 역할은 단순히 코드를 작성하는 것에 그치지 않고, 동료 프로그래머를 비롯해 기획자·디자이너·사운드·QA 등 다양한 팀원들과 원활하게 협업하고 소통하는 역량</span>이 프로젝트의 완성도를 좌우한다는 점을 깊이 깨달았습니다.  