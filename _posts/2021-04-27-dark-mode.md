---
layout: post
title: 졸작
tags: [Katex, Mermaid, Markdown]
color: rgb(250, 50, 50)
categories: Demo
---

---
<div style="display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 20px;">
  <div style="flex: 1; min-width: 250px; border: 1px solid #444; border-radius: 8px; padding: 15px; background-color: #1c1c1c; color: #fff;">
    <h3>About</h3>
    <p>
      <strong>Wothingthing2</strong>는 솔로 프로젝트로 개발한 <strong>2D 횡스크롤 + 3D 배경 게임</strong>입니다.<br>
      배경은 3D로 구성하고, 플레이어와 몬스터는 2D 스프라이트로 구현하여 <strong>3D/2D 혼합 환경</strong>에서의 게임 경험을 제공합니다.<br>
      혼자 작업 중이며, 프로젝트는 <strong>4월 부터 진행 중</strong>입니다.<br>
      본 프로젝트를 통해 처음으로 <strong>OpenGL 기반 직접 렌더링</strong>을 경험했고,        
      이 과정을 통해 <strong>렌더링 파이프라인, 자료 구조 설계, 패턴 적용</strong> 등 엔진 없이 게임을 개발하는 경험과 전문성을 쌓을 수 있었습니다.
    </p>
  </div>

  <div style="flex: 1; min-width: 250px; border: 1px solid #444; border-radius: 8px; padding: 15px; background-color: #1c1c1c; color: #fff;">
    <h3>Project Info</h3>
    <ul>
      <li><strong>Role:</strong> Programmer</li>
      <li><strong>Team Size:</strong> 1명 (프로그래머 1명)</li>
      <li><strong>Time Frame:</strong> 4월 ~ 진행중 </li>
      <li><strong>Engine:</strong> Custom Engine</li>
	  <li><strong>Tools & Libraries:</strong><br>
  - ASSIMP (3D 모델 로딩)<br>
  - IMGUI / IMGUIZMO (개발용 GUI)<br>
  - JSON Serializer (데이터 직렬화)<br>
  - Visual Leak Detector(메모리 누수 탐지기)<br>
  - OpenGL (렌더링)
</li>
    </ul>
  </div>
</div>

---

## Introduction
이 프로젝트는 **OpenGL**을 사용하여 개발한 **2D 횡스크롤 + 3D 배경 게임**입니다.  
그래픽스 API(OpenGL)만을 이용해 게임을 구현하고 
좋은 퀄리티의 코드를 만들려고 노력하고
새로 배우고 알아가는 내용도 많아 **특히 애정이 많이 가는 프로젝트**가 되었습니다.  

지금까지 다양한 렌더링 툴과 게임 엔진을 사용하며 쌓은 경험을 바탕으로,  
이번 프로젝트에서는 **엔진 없이 직접 게임 시스템과 렌더링 파이프라인을 설계하고 구현**하면서  
프로그래밍 역량을 한 단계 더 성장시키는 중입니다.

---

## 주요 구현 내용

### 1. Object Pooling & Factory Pattern 
- 다수의 몬스터와 오브젝트를 생성/삭제할 때 발생하는 성능 저하 문제를 해결하기 위해 **Object Pooling과 Factory Pattern**을 적용했습니다.  
- 이를 통해 메모리 할당/해제를 최소화하고, 새로운 오브젝트 추가 시 **유지보수성과 확장성**을 확보할 수 있었습니다.  
- 결과적으로 프레임 안정성을 유지하면서, 오브젝트 관리 구조를 효율적으로 설계할 수 있었습니다.

### 2. Real-Time Lighting (실시간 조명)  
- 3D 배경 환경에서 실시간 조명과 그림자를 구현하기 위해 **조명 계산을 직접 셰이더로 구현**했습니다.  
- 각 오브젝트의 Material과 Light 정보를 기반으로 **Phong 모델 기반 조명 계산**을 적용하여 자연스러운 조명 효과를 제공했습니다.  
- 이 과정을 통해 **OpenGL 렌더링 파이프라인과 셰이더 설계**에 대한 이해를 깊이 있게 다질 수 있었습니다.

### 3. AI & Animation (FSM 구조)
- 플레이어 및 몬스터 행동을 제어하기 위해 **Finite State Machine(FSM)** 구조로 AI와 애니메이션 시스템을 설계했습니다.  
- 공격, 이동, 피격 등 상황별 행동을 모듈화하여 **확장성과 유지보수성**을 확보하고, 자연스러운 게임플레이를 구현했습니다.  
- 이를 통해 **게임 캐릭터의 동작 논리 설계와 애니메이션 전환**에 대한 경험을 얻었습니다.

### 4. 빌보드 렌더링
- 2D 스프라이트 캐릭터가 3D 배경 속에서 항상 카메라 방향을 바라보도록 **빌보드 렌더링**을 적용했습니다.  
- 카메라 이동 시 캐릭터가 가려지거나 왜곡되지 않도록 조정하여 **플레이어 시야와 게임 몰입감**을 향상시켰습니다.

### 5. Skybox 구현  
- 게임 배경의 몰입감을 높이기 위해 **Skybox**를 구현하여 3D 환경에 자연스러운 하늘과 원근감을 추가했습니다.  
- Skybox의 렌더링 순서를 고려하고, 카메라 이동에 따른 동적 적용을 통해 **씬 구성과 환경 디자인 이해**를 강화했습니다.

### 6. ASSIMP 모델 로딩 / JSON Serializer 
- **ASSIMP**를 이용해 외부 3D 모델을 로드하고, Mesh와 Material 데이터를 게임 내 렌더링에 맞게 처리하여 모델이 올바르게 화면에 표시되도록 구현했습니다.  
- 게임 상태 및 레벨 정보를 **JSON Serializer**로 저장/불러오기 가능하도록 구현하여 **데이터 관리와 재사용성**을 확보했습니다.  
- 이를 통해 **리소스 관리와 직렬화 구조 설계 능력**을 체득할 수 있었습니다.

### 7. Real-Time Collision Detection(매 프레임 충돌 검사)  
- 게임 내 모든 충돌 가능한 오브젝트를 **Collision Manager**를 통해 매 프레임마다 검사하도록 구현했습니다.  
- 싱글톤 패턴을 활용하여 효율적인 접근과 관리가 가능하며, 충돌 처리 로직을 모듈화하여 **확장성과 유지보수성**을 확보했습니다.  
- 이를 통해 **게임 시스템 핵심인 실시간 충돌 처리** 경험을 얻었습니다.  

---

# 어려웠던 점과 해결 방안
### 1. 투명/불투명 오브젝트 렌더링 문제

#### 문제
- 초기에는 **투명 오브젝트가 불투명 오브젝트를 가리는 현상**이 발생했습니다.

#### 원인
- **알파 블렌딩(Alpha Blending) 적용 시 렌더링 순서 중요**  
- 불투명 오브젝트와 투명 오브젝트를 한 번에 그리면 **depth buffer 때문에 올바르게 표시되지 않음**  

#### 해결
- 교수님의 조언을 받아 **투명 오브젝트와 불투명 오브젝트를 분리하여 렌더링**  
  - 불투명 오브젝트: depth test 적용 후 먼저 렌더링  
  - 투명 오브젝트: 카메라로부터 먼 순서대로 뒤에서 앞으로 정렬 후 렌더링  

#### 결과
- 투명 오브젝트가 불투명 오브젝트를 가리는 문제가 해결됨  
- **자연스러운 반투명 효과와 씬 렌더링 안정성** 확보  
- OpenGL 렌더링 파이프라인, 셰이더, Mesh/Material 구조 이해 심화
---

### 2.몬스터 AI 구현과 상태 관리 문제

#### 문제
- 몬스터 AI를 구현하면서 **상태 클래스와 행동 로직이 섞이는 문제**가 발생했습니다.  
- 상태 클래스(`IdleState`, `RangedState`, `TraceState`) 안에서 **몬스터별 공격 분기문(if/else)**이 많아져 코드가 복잡하고 유지보수가 어려웠습니다.  
- 새로운 몬스터 추가 시 상태 클래스를 수정해야 하는 **확장성 부족** 문제도 존재했습니다.

#### 원인
- 상태 전환과 몬스터별 행동을 한 클래스에서 모두 처리 → 단일 책임 원칙(SRP) 위반  
- 분기문 증가 → 코드 가독성 저하, 유지보수 어려움  
- 새로운 몬스터 추가 시 상태 클래스 수정 필요 → 확장성 부족  

#### 문제 코드 예시 (기존 구조)
```cpp
//원거리 공격 State
class RangedState : public BaseState 
{
public:
    void Update() override 
    {	
        Monster* mon_comp = dynamic_cast<Monster*>(GetAI()->GetOwner()->FindComponent<Monster>());
        //몬스터 일때
        if (mon_comp != nullptr) 
        {
            // 몬스터 타입별 공격 분기
            auto type = mon_comp->GetType();
            //아랍 병사 : 칼 던지기 공격
            if (type == MonsterType::ArabSoldier)
                Bullet* bullet = mon_comp->GetBulletFactory()->CreateBullet(BULLET_TYPE::KNIFE);
            //일반 병사 : 총알 발사 공격
            else if (type == MonsterType::GenericSoldier) 
                Bullet* bullet = mon_comp->GetBulletFactory()->CreateBullet(BULLET_TYPE::NORMAL);
            //계속 늘어나는 else if 문
            else if (type == MonsterType::other)
            {
            }
            .
            .
            .
        }
    }
};
```


### 해결책: 전략 패턴 적용

- 몬스터별 행동을 별도 전략 객체로 분리 (Strategy Pattern)
- 행동 인터페이스(`IRangedAttackBehavior`, `IIdleBehavior`) 정의
- 상태 클래스는 행동 호출만 수행, 실제 행동은 전략 객체에 위임
- AI 클래스는 상태 전환만 담당


### 개선된 코드 구조
````cpp
// 행동 인터페이스
class IRangedAttackBehavior 
{
public:
    virtual void Execute(Monster* _mon) = 0;
    virtual ~IRangedAttackBehavior() = default;
};

// GenericSoldier 전용 행동
class GenericSoldierRanged : public IRangedAttackBehavior 
{
public:
    void Execute(Monster* _mon) override 
    {
        Bullet* bullet = _mon->GetBulletFactory()->CreateBullet(BULLET_TYPE::NORMAL);
        EventManager::GetInstance()->SetActiveTrue(bullet->GetOwner());    
    }
};

// ArabSoldier 전용 행동
class ArabSoldierRanged : public IRangedAttackBehavior 
{
public:
    void Execute(Monster* _mon) override 
    {
        Bullet* bullet = _mon->GetBulletFactory()->CreateBullet(BULLET_TYPE::KNIFE);
        EventManager::GetInstance()->SetActiveTrue(bullet->GetOwner());
    }
};
````


#### 몬스터 전략 클래스
<div class="mermaid">
flowchart TD
    MonsterAI[MonsterAI]
    RangedState2[RangedState]
    MonsterAI -->|SetState| RangedState2
    RangedState2 -->|Update| IRangedBehavior[IRangedAttackBehavior]
    IRangedBehavior --> GenericSoldierBehavior[GenericSoldierRanged]
    IRangedBehavior --> ArabSoldierBehavior[ArabSoldierRanged]
</div>

---

# 학습 및 성장
- OpenGL 기반 **실제 게임 렌더링 파이프라인** 이해  
- **싱글톤, 전략 패턴 등 설계 패턴** 적용 경험  
- 3D 모델 로딩, 재질 처리, 충돌 관리 등 **게임 시스템 핵심 요소 직접 구현** 경험  

# 느낀 점
직접 엔진 없이 게임을 구현하면서, **기본적인 렌더링 원리와 게임 시스템 설계**를 깊이 이해할 수 있었습니다.  
특히 ASSIMP, Collision Manager, JSON Serializer 등 각 모듈을 직접 설계하고 구현하면서, **재사용성, 유지보수성, 확장성**의 중요성을 체감했습니다.  
단순히 동작하는 게임을 만드는 것을 넘어, **구조적이고 안정적인 코드 설계**가 장기적인 프로젝트 완성도에 결정적이라는 것을 배웠습니다.

## Code highlight
Mode specific code highlighting themes. [Kramdown](https://kramdown.gettalong.org/) which is responsible for the color highlighting may be more limited than your IDE.

```python
#!/usr/bin/env python
"""
Test file for syntax
"""
# TODO: Use dark mode
from sys import os

def foo(bar): 
    try:
        print(bar)
    except NameError:
        print("Variable bar is not defined")


class Bar(object): 
    def __init__(self):
        foo(1)
        self.octal = '\04'
        self.text = """Example \t\n"""
    
    def __exit__(self, *args):
        print('exit\u1111\xFF')
        pass
    
    @staticmethod
    def example():
        assert (1.0 and 2L) or True
        return { "example": [(1,), (r'raw', u'unicode')]}
```

## Tables

| hex | dec | oct |
| -   | -   | -   |
| 0   | 0   | 0   |
| 5   | 5   | 5   |
| A   | 10  | 12  |
| F   | 16  | 20  |
| F5  | 21  | 25  |

## KaTeX

Some KaTeX diagrams to check in dark mode:

$$
\begin{CD}
A @>a>> B \\
@VbVV @AAcA \\
C @= D
\end{CD}
$$

$$\utilde{AB}$$

## Mermaid

<div class="mermaid">
flowchart TB
    c1-->a2
    subgraph one
    a1-->a2
    end
    subgraph two
    b1-->b2
    end
    subgraph three
    c1-->c2
    end
</div>
