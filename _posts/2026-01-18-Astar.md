---
layout: post
title: PathFind Simulator
tags: [Katex, Mermaid, Markdown]
color: rgb(250, 50, 50)
categories: Demo
feature-img: "assets/astarThum.png"
thumbnail: "assets/astarThum.png"
badges:   
  - label: "Asynchronous"
    color: "#34495E"  
  - label: "WPF"
    color: "#6cad41"
     
---


<div style="display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 20px;">
  <div style="flex: 1; min-width: 250px; border: 1px solid #444; border-radius: 8px; padding: 15px; background-color: #1c1c1c; color: #fff;">
    <h3>프로젝트 소개</h3>
    <p>
      <strong>격자(Grid)</strong> 환경에서 장애물을 회피하여 최단 경로를 탐색하고<br> 시각적 최적화를 수행하는 WPF 기반<strong> 경로 계획 시뮬레이터</strong><br>
      단순히 최단 거리를 찾는 A* 알고리즘에 그치지 않고 실제 현장에서 객체가 주행할 때 발생하는 지그재그 이동의 비효율성을 해결하기 위해 <strong>Rubber Banding</strong> 기술을 도입하여 매끄러운 직선 주행 경로를 도출.
    </p>
  </div>

  <div style="flex: 1; min-width: 250px; border: 1px solid #444; border-radius: 8px; padding: 15px; background-color: #1c1c1c; color: #fff;">
    <h3>프로젝트 정보</h3>
    <ul>
      <li><strong>역할 :</strong> Programmer</li>
      <li><strong>팀 규모 :</strong> 1명 (프로그래머 1명)</li>
      <li><strong>개발 기간 :</strong> 3일 </li>      
	  <li><strong>사용 기술 & 스택 :</strong><br>
  - C# (.NET)<br>
  - WPF (UI)<br>  
</li>
    </ul>
  </div>
</div>
---


# 최종결과물
<iframe width="960" height="515" src="https://www.youtube.com/embed/tyGwd0AZXoo" 
        title="PathFind Simulator" frameborder="0" 
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
        allowfullscreen></iframe>
---

## 주요 구현 내용

### 1. A* 알고리즘 및 커스텀 자료구조 구현
- <strong>우선순위 큐(Priority Queue) 최적화</strong> : 최소 힙(Min-Heap) 구조를 직접 구현하여 탐색 중 최소 비용 노드를 추출하는 과정의 시간 복잡도를 O(log n)으로 최적화.

- <strong>다중 휴리스틱(Heuristic) 지원</strong> : Manhattan, Euclidean, Octile 방식의 휴리스틱 함수를 델리게이트 패턴으로 구현하여 상황에 맞는 최적의 탐색 효율을 선택할 수 있게 설계.

- <strong>8방향 탐색 및 비용 계산</strong> : 상하좌우(10)와 대각선(14) 이동 비용을 차등 적용하여 실제 물리적 거리에 가까운 경로를 산출.

### 2. 주행 효율 확대를 위한 경로 최적화 (Rubber Banding)
- <strong>Bresenham 알고리즘 기반 Line of Sight(LoS)</strong> : 두 노드 사이의 직선상에 장애물이 있는지 확인하는 LoS 체크 로직을 구현.
- <strong>경로 가지치기(Path Pruning)</strong> : 탐색된 노드 중 불필요한 경유지를 제거하여 장애물에 걸리지 않는 한 최대한 먼 거리를 직선으로 잇는 '실제 주행 경로'를 생성.

### 3. 동적 장애물 감지
- 실시간 지형 인지: 격자 상에 실시간으로 배치되는 장애물을 감지하여 이동 가능 여부를 판단.


<div style="margin-top:80px;"></div>
---
<div style="margin-top:80px;"></div>
# 어려웠던 점과 해결 방안
### Euclidean Heuristic과 8방향 이동 모델 불일치 문제

#### 문제
- **Grid 기반** A* 알고리즘에 **Euclidean heuristic**을 적용했을 때 경로가 장애물에 과도하게 근접하거나 Rubber Banding 적용 후에도 비현실적으로 벽을 스치는 문제가 발생

#### 원인
- **8방향 Grid (격자 기반, 이산 공간)**  VS **Euclidean 거리 (연속 공간, 자유 방향 이동 가정)**
- Euclidean은 **“어디든 직선 이동 가능”**을 가정하지만 실제 탐색은 **“8방향으로만 이동 가능”**한 구조였다.
  - 휴리스틱이 실제 비용을 과소평가.
  - 경로가 장애물에 지나치게 붙음.
  - Rubber Banding 시 벽을 스치는 직선 경로 생성.   

#### 문제 코드
Euclidean을 사용하면서도 기존 A* 방식처럼 항상 현재 노드를 부모로 설정한 구조였다.

````c#
tentativeG = cur.Gn + Distance(cur, next_node);
next_node.Parent = cur;
````
Euclidean의 **“직선 이동”** 가정을 전혀 활용하지 못하고
결과적으로 8방향(Manhattan, Octile, Chebyshev등등) Grid A*와 다를 바 없는 경로를 생성했다.

#### 해결
  - Euclidean heuristic은 연속 공간 가정에 맞게 사용
  - 단순한 8방향 이동 대신 부모 노드 기준 **Line-of-Sight** 검사를 통해 실제로 직선 이동이 가능한 경우 부모를 재설정
  - 이를 통해 **Theta(*)** 알고리즘 개념을 도입  

#### 개선된 코드
````c#
if (method_type==(int)HueristicType.EUCLIDEAN)
{
    if (cur.Parent != null && LineOfSight(cur.Parent, next_node))
    {
        tentativeG = cur.Parent.Gn + Distance(cur.Parent, next_node);
        next_node.Parent = cur.Parent;
    }
    else
    {
        tentativeG = cur.Gn + Distance(cur, next_node);
        next_node.Parent = cur;
    }
}

````

<br>

#### <span style="font-size:32px; font-weight:900;">성과 및 결과</span>
- 장애물에 과도하게 밀착되던 경로 문제 해결
- 불필요한 꺾임 감소 → 경로 길이 단축    
- Rubber Banding 이후에도 자연스러운 직선 경로 생성
- Heuristic, 탐색 모델, 후처리 알고리즘 간의 이론적 일관성 확보
- **Theta(*)** 개념을 실제 코드에 적용하며알고리즘 변형의 필요성과 효과를 체감

<div style="margin-top:60px;"></div>
---
<div style="margin-top:60px;"></div>

# 배운 점 및 느낀점
- Grid 기반 A*는 경로 탐색 알고리즘을 이해하기에 좋은 모델이지만 실제 로봇이나 게임 환경에서는 연속적인 공간에서의 이동을 다루는 경우가 대부분이라는 점을 다시 생각하게 되었다.
- 단순히 Grid 위에서 최단 경로를 찾는 데 그치지 않고 연속 공간에서의 이동 가정을 어떻게 격자 탐색에 반영할 수 있을지를 고민했고 그 결과 Line-of-Sight 기반 Theta* 방식이 더 적합하다는 결론에 도달했다.
> <span style="font-weight:bold; color:rgb(255,200,100);">이 경험을 통해 알고리즘을 “그대로 구현하는 것”보다 왜 이런 가정이 필요한지 어떤 환경에서 적합한지를 이해하는 것이 중요하다는 점을 배웠다.</span> 또한 A＊를 Theta＊로 확장하는 과정을 통해 기존 알고리즘을 상황에 맞게 변형하고 개선하는 것이 실제 문제 해결에서 중요한 역량임을 느꼈다.