---
layout: post
title: H-Chat
tags: [Katex, Mermaid, Markdown]
color: rgb(250, 50, 50)
categories: Demo
feature-img: "assets/H_ChatThum.png"
thumbnail: "assets/H_Chat.png"
badges: 
  - label: "MultiThreading"
    color: "#E67E22" 
  - label: "Asynchronous"
    color: "#34495E"
  - label: "TCP/IP"
    color: "#16A085"   
  - label: "Winform"
    color: "#9B59B6"
     
---


<div style="display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 20px;">
  <div style="flex: 1; min-width: 250px; border: 1px solid #444; border-radius: 8px; padding: 15px; background-color: #1c1c1c; color: #fff;">
    <h3>프로젝트 소개</h3>
    <p>
      <strong>H-Chat</strong>은 C#의 <strong>TCP/IP 통신</strong>을 기반으로 구축된 <strong>멀티스레딩 및 비동기</strong> 기반의 <strong>1:N 채팅</strong> 시스템입니다.<br><br>
      서버는 다수의 클라이언트를 수용하며 클라이언트 간 <strong>실시간 메시지 중계(Broadcasting)</strong>를 지원합니다.<br>
    </p>
  </div>

  <div style="flex: 1; min-width: 250px; border: 1px solid #444; border-radius: 8px; padding: 15px; background-color: #1c1c1c; color: #fff;">
    <h3>프로젝트 정보</h3>
    <ul>
      <li><strong>역할 :</strong> Programmer</li>
      <li><strong>팀 규모 :</strong> 1명 (프로그래머 1명)</li>
      <li><strong>개발 기간 :</strong> 3일 </li>      
	  <li><strong>사용 기술 & 스택 :</strong><br>
  - C#(.Net)<br>
  - Winform (메시지 창 UI)<br>  
</li>
    </ul>
  </div>
</div>

---

# 최종결과물
<iframe width="960" height="515" src="https://www.youtube.com/embed/a1axPMNIogE" 
        title="PathFind Simulator" frameborder="0" 
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
        allowfullscreen></iframe>
---


# Version_(1) : Multi-threaded Chat System

## 주요 구현 내용 
**전통적인 스레드 생성 방식의 서버 구조 설계 및 동기화**<br>

### 1. 클라이언트 동시 접속 처리 
- TcpListener와 Thread/Task.Run을 이용한 **1:N 멀티유저** 접속 처리.

### 2. Lock 기반 동기화
- **Lock(client_lock)**을 활용하여 여러 클라이언트가 동시에 접속하거나 메시지를 보낼 때 공유 자원(List)의 데이터 무결성 보장.

### 3. Blocking I/O 활용
- BinaryReader/Writer를 통한 직관적인 데이터 송수신 처리.


<!-- <div style="text-align: center; margin: 30px 0;">
  <img src="/assets/player_particle.gif" alt="player_particle" 
       style="width: 80%; max-width: 1200px; height: auto; border-radius: 8px;" />
  <p style="color: #aaa; font-size: 0.9em;">▲ 파티클을 이용한 스킬 모습</p>
</div> -->

<div style="margin-top:50px;"></div>

## 한계점 (Version2의 핵심동기)
### 1. 자원 고갈 문제
클라이언트 수가 늘어날수록 시스템 스레드 수가 기하급수적으로 증가합니다. 스레드는 생성될 때마다 독립적인 **스택 메모리(기본 1MB)**를 점유하므로, 대규모 접속 시 메모리 부족 현상이 발생.

### 2. 과도한 ContextSwitching 비용
CPU 코어 수는 한정되어 있는데 스레드가 너무 많아지면 CPU가 스레드를 교체하는 데 드는 비용(Context Switching)이 실제 데이터를 처리하는 비용보다 커져서 전체적인 서버 성능이 저하.

### 3. 동기적 블로킹(Blocking)의 한계
Read() 메서드 호출 시 데이터가 올 때까지 해당 스레드는 아무 작업도 못 하고 멈춰있게 됩니다. 이는 시스템 자원을 매우 비효율적으로 사용.

<div style="margin-top:60px;"></div>
>  버전 1에서의 '1인 1스레드' 방식은 소규모 채팅에는 적합하지만 수천 명의 사용자를 수용하기엔 메모리와 CPU 자원 낭비가 심하다는 점을 인지. <span style="color:rgb(255,200,100); font-weight:bold;">이를 해결하기 위해 I/O Bound 작업에서 스레드를 점유하지 않는 **비동기 프로그래밍 모델(Asynchronous)**로 전환.
<div style="margin-top:60px;"></div>




# Version_(2) : Asynchronous Chat System
**비동기 프로그래밍 모델(async/await)을 통한 서버 자원 효율성 최적화**
## 주요 구현 내용 
### 1.Async/Await 패턴 적용
- AcceptTcpClientAsync, ReadAsync, WriteAsync를 도입하여 I/O 작업 시 스레드 점유 최소화.

### 2. Non-blocking I/O 구현
- 대규모 접속 상황에서 스레드 생성 오버헤드를 줄여 서버 시스템 자원(Memory, CPU) 효율성 극대화.

### 3. 커스텀 프로토콜 설계
- 문자열 구분자( │ )를 이용한 메시지 파싱 시스템 구축 (Sender 정보와 Content 분리).

### 4. 공통 모듈 분리
- 서버와 클라이언트에서 공통으로 사용하는 통신 로직을 ChatCore.dll 라이브러리로 모듈화.


<!-- 상황: 메시지를 받았는데 RichTextBox에 텍스트가 안 찍히거나 프로그램이 응답 없음 상태가 됨.

어려웠던 점: 네트워크 수신 쓰레드(백그라운드)에서 UI 요소에 직접 접근하려고 할 때 발생하는 보안 오류를 겪었습니다. 비동기 작업과 UI 업데이트 쓰레드가 서로 다르다는 점을 이해하는 것이 어려웠습니다.

해결책: Control.Invoke 또는 this.Invoke를 사용하여 UI 업데이트 로직을 메인 쓰레드(UI 쓰레드)의 메시지 큐로 전달하는 방식으로 해결했습니다 -->

# 어려웠던 점과 해결 방안
### 크로스 스레드(Cross Thread) 현상

#### 문제
- 메시지를 받았는데 RichTextBox(메시지 창)에 텍스트가 안 찍히거나 프로그램이 응답 없음 상태가 됨.

#### 원인
- Windows Forms(WinForms)의 UI 컨트롤들은 **단일 스레드 모델**을 따른다 즉 컨트롤을 생성한 메인 스레드(UI 스레드)만이 해당 컨트롤을 수정할 수 있습니다. 
- 서버의 메시지 수신 로직(ReceiveLoop)은 별도의 백그라운드 스레드에서 동작하므로 이 스레드에서 UI 컨트롤에 직접 접근하는 것은 스레드 안전성(Thread-safety) 위반.

#### 문제 코드
````c#
private void OnClientMessage(ChatHandler.Common.ChatHandler sender,string msg)
{
    string senderInfo=((IPEndPoint)sender.Client.Client.RemoteEndPoint).ToString();

    // ↓ 문제 코드
    richTextBox1.AppendText($"{senderInfo} : {msg}\n");
    // ↑ 문제 코드

    string formatMsg = senderInfo +" : "+ msg;
    
    BroadCast(sender, formatMsg);
}
````

#### 해결
  - 백그라운드 스레드에서 UI 컨트롤에 접근할 때 발생하는 크로스 스레드 예외를 방지하기 위해 Control.Invoke 메서드를 도입.
  - UI 업데이트 로직을 Action 대리자로 캡슐화하여 스레드 안전성(Thread-safety)을 확보.

#### 개선된 코드
````c#
private void OnClientMessage(ChatHandler.Common.ChatHandler sender,string msg)
{
    string senderInfo=((IPEndPoint)sender.Client.Client.RemoteEndPoint).ToString();            

    // ↓ 개선 코드
    this.Invoke(new Action(() =>
    {
        richTextBox1.AppendText($"{senderInfo} : {msg}\n");
    }));
    // ↑ 개선 코드

    string formatMsg = senderInfo +" : "+ msg;
    BroadCast(sender, formatMsg);
}
````
<br>

#### <span style="font-size:32px; font-weight:900;">성과 및 결과</span>
- (1) 시스템 아키텍처 고도화 (V1 → V2)
  - Version (1) : 접속자당 1개의 스레드 점유 (Memory ↑)
  - Version (2) : I/O 완료 시에만 스레드 할당 (Memory ↓)
  - <span style="font-weight:bold; color:rgb(255,200,100);">결과 :  비동기 Non-blocking I/O 모델 채택을 통해 서버 메모리 사용량을 최적화하고 컨텍스트 스위칭 오버헤드를 줄여 **대규모 접속 수용 능력(Scalability)**을 확보했습니다.</span>  
  <br>
- (2) 데이터 무결성 보장 및 크로스 스레드 결함 해결
  - 크로스 스레드 결함 해결 : 백그라운드 스레드와 UI 스레드 간의 충돌을 해결.
  - 데이터 무결성 보장 : 공유 자원 접근 시 lock을 이용한 동기화 처리를 수행하여 클라이언트의 빈번한 접속/해제 시에도 런타임 에러 없는 견고한 서버를 완성했습니다.


<div style="margin-top:60px;"></div>
---
<div style="margin-top:60px;"></div>

# 배운 점 및 느낀점
- 처음에는 기능 구현에만 집중하여 **Version 1(멀티쓰레딩)**을 설계했으나 접속자가 늘어날수록 급증하는 스레드 수와 자원 낭비 문제를 직면했습니다. 이를 해결하기 위해 **Version 2(비동기 I/O)**로 리팩토링하며 소프트웨어 아키텍처 하나가 전체 시스템의 **확장성(Scalability)**에 얼마나 큰 영향을 미치는지 깊이 깨달음.
<br>
- 서버와 클라이언트의 공통 로직을 ChatCore.dll 라이브러리로 분리해 보며 코드 중복을 줄이는 것뿐만 아니라 유지보수의 효율성을 경험했습니다. 프로젝트 초기 설계 단계에서부터 모듈화와 재사용성을 고민하는 습관이 개발 시간을 단축하고 협업 효율을 높인다는 것을 실감.

> <span style="font-weight:bold; color:rgb(255,200,100);">이 경험을 바탕으로 앞으로 대규모 데이터 처리나 고성능 시스템 개발에서도 자원 효율을 먼저 생각하는 계기가 되었음</span>