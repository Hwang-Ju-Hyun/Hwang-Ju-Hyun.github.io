---
layout: post
title: H-Chat
tags: [Katex, Mermaid, Markdown]
color: rgb(250, 50, 50)
categories: Demo
feature-img: "assets/thum.png"
thumbnail: "assets/thum6.png"
badges: 
  - label: "MultiThreading"
    color: "#E67E22" 
  - label: "Asynchronous"
    color: "#34495E"
  - label: "TCP/IP"
    color: "#16A085"   
  - label: "Winform"
    color: "#9B59B6"
     
---


<div style="display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 20px;">
  <div style="flex: 1; min-width: 250px; border: 1px solid #444; border-radius: 8px; padding: 15px; background-color: #1c1c1c; color: #fff;">
    <h3>프로젝트 소개</h3>
    <p>
      <strong>H-Chat</strong>은 C#의 <strong>TCP/IP 통신</strong>을 기반으로 구축된 <strong>멀티스레딩 및 비동기</strong> 기반의 <strong>1:N 채팅</strong> 시스템입니다.<br><br>
      서버는 다수의 클라이언트를 수용하며 클라이언트 간 <strong>실시간 메시지 중계(Broadcasting)</strong>를 지원합니다.<br>
    </p>
  </div>

  <div style="flex: 1; min-width: 250px; border: 1px solid #444; border-radius: 8px; padding: 15px; background-color: #1c1c1c; color: #fff;">
    <h3>프로젝트 정보</h3>
    <ul>
      <li><strong>역할 :</strong> Programmer</li>
      <li><strong>팀 규모 :</strong> 1명 (프로그래머 1명)</li>
      <li><strong>개발 기간 :</strong> 3일 </li>      
	  <li><strong>사용 기술 & 스택 :</strong><br>
  - C#(프로그래밍 언어)<br>
  - Winform (메시지 창 UI)<br>
  - .NetFramework<br>  
</li>
    </ul>
  </div>
</div>

---

  
<div style="
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
  margin: 30px 0;
  flex-wrap: wrap;
">
  <img src="/assets/normal.gif" alt="normal"
       style="flex: 1; min-width: 55%; height: 420px; object-fit: cover; border-radius: 8px;" />

  <img src="/assets/cone.gif" alt="cone"
       style="flex: 1; min-width: 55%; height: 420px; object-fit: cover; border-radius: 8px;" />
</div>

## 주요 구현 내용 

#### Version_(1) : Multi-threaded Chat System
"전통적인 스레드 생성 방식의 서버 구조 설계 및 동기화 메커니즘 습득"

### 1. 클라이언트 동시 접속 처리 
- TcpListener와 Thread/Task.Run을 이용한 1:N 멀티유저 접속 처리.

### 2. Lock 기반 동기화
- Lock(client_lock)을 활용하여 여러 클라이언트가 동시에 접속하거나 메시지를 보낼 때 공유 자원(List)의 데이터 무결성 보장.

### 3. Blocking I/O 활용
- BinaryReader/Writer를 통한 직관적인 데이터 송수신 처리.


<div style="text-align: center; margin: 30px 0;">
  <img src="/assets/player_particle.gif" alt="player_particle" 
       style="width: 80%; max-width: 1200px; height: auto; border-radius: 8px;" />
  <p style="color: #aaa; font-size: 0.9em;">▲ 파티클을 이용한 스킬 모습</p>
</div>

# 어려웠던 점과 해결 방안
### 1. 투명/불투명 오브젝트 렌더링 문제

#### 문제
- 초기에는 **투명 오브젝트가 불투명 오브젝트를 가리는 현상**이 발생했습니다.

#### 원인
- **알파 블렌딩(Alpha Blending) 적용 시 렌더링 순서가 중요**
- **Depth Buffer 동작 방식 때문에 발생**  
  - GPU는 기본적으로 **각 픽셀에 가장 가까운 오브젝트만 그리는 방식(depth test)**을 사용  
  - 불투명 오브젝트는 depth test를 통과한 후 그려지고, 뒤에 있는 픽셀은 덮어쓰지 않음  
  - 하지만 투명 오브젝트는 **픽셀 색상을 기존 색상과 섞어야 하기 때문에 뒤에 있는 오브젝트도 고려**해야 함  
  - 따라서 투명 오브젝트를 먼저 그리면 뒤에 있는 불투명 오브젝트가 이미 depth buffer에 막혀 보이지 않게 됨 

#### 문제 코드
````cpp
// 투명 불투명 오브젝트들을 구분하지도 않으며 한꺼번에 모든 오브젝트를 투명여부에 상관없이 그리고 있는 상황 
for (auto obj : objs)
{		
    //비활성화 오브젝트는 Draw(X)
    if (!obj->GetActive())
	    continue;
	   
    auto model = obj->GetModel();

    if (model && obj->GetIs3D())
    {
        m_vShdr[int(SHADER_REF::THREE_DIMENSIONS)]->Use();
		
        //Model View Location Uniform 핸들		
        GLint MVP_Location = glGetUniformLocation(shdr_handle_3D, "uMVP");
        assert(MVP_Location >= 0);
        
        //각 오브젝트 Transform 
        Transform* trs = dynamic_cast<Transform*>(obj->FindComponent<Transform>());
        assert(trs != nullptr);		
		.
		.
		.
    
	}
````

#### 해결
  - 검색을 통하여 **투명 오브젝트와 불투명 오브젝트를 분리하여 렌더링**  
  - 불투명 오브젝트: depth test 적용 후 먼저 렌더링  
  - 투명 오브젝트: 카메라로부터 먼 순서대로 뒤에서 앞으로 정렬 후 렌더링  

#### 개선된 코드
````cpp
//그리기 전 투명과 불투명 오브젝트들을 구분하는 작업 먼저 수행
void RenderManager::BeforeDraw()
{
    //매프레임 채워져있던 메모리들을 정리 후 수행
    m_vTransParnetObject.clear();
    m_vOpaqueObject.clear();
	
    auto objs = GameObjectManager::GetInstance()->GetAllObjects();
    
    for (const auto& obj : objs)
    {		
        for (int i = 0;i < obj->GetModel()->GetMeshes().size();i++)
        {
            Material* mat = obj->GetModel()->GetMeshes()[i]->GetMaterial();
            if (mat)
			{			
                //알파값 존재 여부			
                if (mat->GetHasAlphaChannel())
                {
                    //투명
                    m_vTransParnetObject.push_back(obj);
                }						
                else
                {
                    //불투명
                    m_vOpaqueObject.push_back(obj);
                }
            }
        }
        .
        .
        .
    }

void RenderManager::Draw()
{
    //그리기 전
    BeforeDraw();
    
	//그리기
    //불투명 먼저
    for (const auto obj : m_vOpaqueObject)
    {	
        //비활성화 오브젝트는 Draw(X)
        if (!obj->GetActive())
	        continue;
	    .
	    .
	    .
    }
	
    //그리고 투명
    for(const auto obj : m_vTransParnetObject)
    {
        .
        .
        .
    }
	
    //그린 후
    EndDraw();
}

//다 그린 후 메모리 Capacity까지 온전히 정리(삭제)	
void RenderManager::EndDraw()
{		
    std::vector<GameObject*> TransParent_temp,Opaque_temp;
    TransParent_temp.swap(m_vTransParnetObject);
    Opaque_temp.swap(m_vOpaqueObject);
}
````
<br>

#### <span style="font-size:32px; font-weight:900;">성과 및 결과</span>
- <span style="font-weight:bold; color:rgb(255,200,100);">렌더링 오류 발생 빈도 0%</span> 달성  
- <span style="font-weight:bold;">렌더링 구조 전반에 대한 실전 기반 이해 확보</span>
- 투명 오브젝트가 불투명 오브젝트를 가리는 문제가 해결됨  
- **자연스러운 반투명 효과와 씬 렌더링 안정성** 확보  
- OpenGL 렌더링 파이프라인, 셰이더, Mesh/Material 구조 이해 심화<br>

<div style="margin-top:60px;"></div>
---
<div style="margin-top:60px;"></div>

### 2.몬스터 AI 구현과 상태 관리 문제
- **패턴이 다소 간단한 몬스터들은 Behavior Tree를 사용하지 않고 FSM구조를 통해 구현하였습니다.**
#### 문제
- 몬스터 AI를 구현하면서 **상태 클래스와 행동 로직이 섞이는 문제**가 발생했습니다.  
- 상태 클래스(`IdleState`, `RangedState`, `TraceState`) 안에서 **몬스터별 공격 분기문(if/else)**이 많아져 코드가 복잡하고 유지보수가 어려웠습니다.  
- 새로운 몬스터 추가 시 상태 클래스를 수정해야 하는 **확장성 부족** 문제도 존재했습니다.

#### 원인
- 상태 전환과 몬스터별 행동을 한 클래스에서 모두 처리 → 단일 책임 원칙(SRP) 위반  
- 분기문 증가 → 코드 가독성 저하, 유지보수 어려움  
- 새로운 몬스터 추가 시 상태 클래스 수정 필요 → 확장성 부족  

#### 문제 코드 예시 (기존 구조)
```cpp
//원거리 공격 State
class RangedState : public BaseState 
{
public:
    void Update() override 
    {	
        Monster* mon_comp = dynamic_cast<Monster*>(GetAI()->GetOwner()->FindComponent<Monster>());
        //몬스터 일때
        if (mon_comp != nullptr) 
        {
            // 몬스터 타입별 공격 분기
            auto type = mon_comp->GetType();
            //아랍 병사 : 칼 던지기 공격
            if (type == MonsterType::ArabSoldier)
                Bullet* bullet = mon_comp->GetBulletFactory()->CreateBullet(BULLET_TYPE::KNIFE);
            //일반 병사 : 총알 발사 공격
            else if (type == MonsterType::GenericSoldier) 
                Bullet* bullet = mon_comp->GetBulletFactory()->CreateBullet(BULLET_TYPE::NORMAL);
            //계속 늘어나는 else if 문
            else if (type == MonsterType::other)
            {
            }
            .
            .
            .
        }
    }
};
```


### 해결책: 전략 패턴 적용

- 몬스터별 행동을 별도 전략 객체로 분리 (Strategy Pattern)
- 행동 인터페이스(`IRangedAttackBehavior`, `IIdleBehavior`) 정의
- 상태 클래스는 행동 호출만 수행, 실제 행동은 전략 객체에 위임
- AI 클래스는 상태 전환만 담당


### 개선된 코드 구조
````cpp
// 행동 인터페이스
class IRangedAttackBehavior 
{
public:
    virtual void Execute(Monster* _mon) = 0;
    virtual ~IRangedAttackBehavior() = default;
};

// GenericSoldier 전용 행동
class GenericSoldierRanged : public IRangedAttackBehavior 
{
public:
    void Execute(Monster* _mon) override 
    {
        Bullet* bullet = _mon->GetBulletFactory()->CreateBullet(BULLET_TYPE::NORMAL);
        EventManager::GetInstance()->SetActiveTrue(bullet->GetOwner());    
    }
};

// ArabSoldier 전용 행동
class ArabSoldierRanged : public IRangedAttackBehavior 
{
public:
    void Execute(Monster* _mon) override 
    {
        Bullet* bullet = _mon->GetBulletFactory()->CreateBullet(BULLET_TYPE::KNIFE);
        EventManager::GetInstance()->SetActiveTrue(bullet->GetOwner());
    }
};
````


#### 몬스터 전략 클래스
<div class="mermaid">
flowchart TD
    MonsterAI[MonsterAI]
    RangedState2[RangedState]
    MonsterAI -->|SetState| RangedState2
    RangedState2 -->|Update| IRangedBehavior[IRangedAttackBehavior]
    IRangedBehavior --> GenericSoldierBehavior[GenericSoldierRanged]
    IRangedBehavior --> ArabSoldierBehavior[ArabSoldierRanged]
</div>

#### <span style="font-size:32px; font-weight:900;">성과 및 결과</span>
- <span style="font-weight:bold; color:rgb(255,200,100);">AI 관련 코드 수정량 약 40% 감소</span>(상태 클래스 내부에서 몬스터별 분기 제거)
- <span style="font-weight:bold;">신규 몬스터 추가 시 수정해야 할 파일 수 4개 → 1개로 감소 </span>(상태 코드는 유지, 전략 클래스만 추가하면 되는 구조로 개선)
- if/else 기반 분기 로직 제거로 <span style="font-weight:bold;">AI Update 로직 가독성 2배 향상</span>
- 상태 전환과 행동 로직이 분리되면서 **FSM 구조의 확장성과 유지보수성 대폭 증가**
- 코드 구조 정리를 통해 **SRP(단일 책임 원칙) 준수 및 디버깅 시간 감소**

<div style="margin-top:60px;"></div>

---

# 배운 점
- OpenGL 3D 기반 **실제 게임 렌더링 파이프라인** 더욱 심도있게 이해할 수 있었습니다. 
- **전략 패턴, 팩토리 패턴 등 디자인 패턴** 적용 및 경험하였습니다.
- 3D 모델 로딩, 충돌 관리, 애니메이션 상태 관리 등 **게임 시스템 핵심 요소 구현** 적용 및 학습하고 실제로 경험할 수 있었습니다.

# 느낀 점
- 프로젝트 규모가 커질수록 코드 복잡도가 증가했지만 **유연성과 유지보수성을 확보하는 방향으로 구조를 지속적으로 개선**하려고 노력했습니다.
- **단일 책임 원칙(SRP)**을 최대한 적용하며 각 모듈의 역할을 명확히 하고, **재사용 가능한 구조**를 만들기 위해 계속 코드 구조를 개선했습니다.  
- SRP와 유연성을 지키면서 **최적의 자료구조와 클래스 구조**를 찾으려 시도하는 과정에서 설계 능력과 문제 해결 능력이 크게 향상되었습니다.  
- 이러한 경험 덕분에, 다음번에 상용 게임 엔진을 사용할 때도 **막연히 기능을 사용하는 것이 아니라, 내부 동작 원리를 이해한 상태에서 기능을 적용**할 수 있다는 자신감을 얻었습니다.  
- 엔진 없이 직접 구현하며 얻은 경험은, 단순히 코드 작성 능력을 넘어서 **게임 시스템 전체를 설계하고 최적화하는 사고**를 기르는 데 큰 도움이 되었습니다.

>  이번 프로젝트를 진행하면서 가장 크게 느낀 점은 **클라이언트 개발에서 작은 설계 결정 하나가 나중에 얼마나 큰 영향을 주는지였습니다.** 
>  초반에 대충 넘긴 부분이 후반에 발목을 잡는 경험을 반복하면서 구조를 처음부터 신중하게 잡는 습관을 가지려 노력중에 있습니다.
>  <br>혼자 개발했지만 그 과정에서 <span style="color:rgb(255,200,100); font-weight:bold;">"왜 실무에서 코드 리뷰가 중요한지", "왜 모듈화가 필수인지", "왜 자료구조가 성능을 좌우하는지" </span>를 실제 상황으로 경험할 수 있었습니다.<br>
>  이런 경험은 책이나 강의로는 절대 얻을 수 없는 몸으로 배우는 인사이트였습니다.
